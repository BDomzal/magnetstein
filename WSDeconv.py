from src.wasserstein import Spectrum
from src.FastIPMDeconv2 import FastIPMDeconv
from getopt import getopt
import sys

doc = """NAME:
    WSDeconv.py
    
USAGE:
    python WSDeconv.py [OPTIONS] FILE1 FILE2
    
EXAMPLES:
    python WSDeconv.py examples/small_molecule_mixture.txt examples/molecule_list.txt
    python WSDeconv.py -p 0.999 examples/small_molecule_mixture.txt examples/molecule_list.txt 
    python WSDeconv.py examples/small_molecule_mixture.txt examples/wrong_molecule_list.txt 
    
DESCRIPTION:
    Deconvolves overlapping isotopic distributions and returns their proportions.
    FILE1 contains the peak list of the experimental spectrum, FILE2 contains the list
    of elemental compositions of molecules which are expected to be present in the spectrum.
    Lines starting with a hash # in any file are treated as comments and skipped.
    A simple denoising procedure and normalization of peak intensities is performed by the program.
    Note that usually, supplying molecules which are not present in the spectrum does not 
    lead to any problems; their proportions are simply 0. However, omitting a molecule
    which is present in a spectrum leads to serious problems due to improper mass transport scheme. 
    A simple check is performed by looking for mass transports on distance greater than 10Da. 
    If this is detected, a warning is issued.  

RETURNS:
    By default, the optimal Wasserstein distance between the experimental spectrum and the mixture
    of theoretical isotopic envelopes is printed to the command line. This is followed by the 
    inferred proportions of molecules. Optionally, the optimal transport scheme of the ion current
    between the experimental and predicted spectrum can be printed. When the application raises a warning 
    about a large-distance mass transport occuring after deconvolution, this can be used to identify 
    the peaks in the experimental spectrum which cause this problem. Those peaks may occur for example because of chemical contamination. 

OPTIONS:
    -h
        Print this message and exit.
    -p: float in [0, 1], default: 0.95
        Theoretical isotopic envelope coverage. 
        This is the percentage of total peak intensity included in the theoretical spectra generated by IsoSpec.
        In general, larger values lead to more accurate results but increase the computational complexity.
    -t: float in [0, 1], default: 0.99
        Fraction of intensity remaining after denoising. Small peaks will be removed in a way such that
        at least this proportion of the total ion current remains in a spectrum. Set to 1 to disable denoising.
    -s
        Print the optimal transport scheme between the experimental spectrum and the mixture of isotopic envelopes.
    -m: int, default: 100
        Maximum iteration limit for the Interior Point Method. 
    -e: float, default: 1e-6
        The stopping condition for the Interior Point Method (see the article for details).
        
CONTACT:
    If you encounter any problems during use of this application, please email me at m_ciach@student.uw.edu.pl.
"""

mass_warning = """
WARNING: Detected a large-distance mass transport between masses %.2f and %.2f. It is advised to inspect the mass transport. 
This warning may indicate that the experimental spectrum has chemical contamination. The results are not be credible.
Fine-tuning the program parameters or additional preprocessing of the experimental spectrum may help to solve this problem. 
"""

prob = 0.95
thr = 0.99
epsilon = 1e-6
max_iter = 100
print_transport = False

opts, args = getopt(sys.argv[1:], 'ht:m:p:e:s')

if not args:
    print(doc)
    quit()

for opt, arg in opts:
    if opt == '-h':
        print(doc)
        quit()
    if opt == '-m':
        max_iter = int(arg)
    if opt == '-t':
        thr = float(arg)
        assert 0 <= thr <= 1, 'Improper threshold value: %f' % thr
    if opt == '-p':
        prob = float(arg)
        assert 0 <= prob <= 1, 'Improper probability value: %f' % prob
    if opt == '-s':
        print_transport = True
    if opt == '-e':
        epsilon = float(arg)

print(("Experimental spectrum:", args[0]))
print(("Molecule list:", args[1]))
print(("Fraction of remaining intensity after denoising:", thr))
print(("Theoretical envelope coverage:", prob))
print() 

# parse spectrum
sp = open(args[0]).readlines()
sp = list(map(str.strip, sp))
sp = [list(map(float, l.split())) for l in sp if l and l[0] != '#']

# pre-denoising normalization
ic_total = sum(l[1] for l in sp)
sp = [(l[0], l[1]/ic_total) for l in sp]

#denoise
if thr < 1:
    order1 = sorted([x for x in enumerate((l[1] for l in sp))], key=lambda y: y[1])  # ordering of intensities
    cmsm1 = reduce(lambda x,y: x + [x[-1] + y], (l[1] for l in order1), [0])[1:]  # cumsum of ordered intensities
    to_remove1 = [o[0] for o, c in zip(order1, cmsm1) if c < 1-thr]  # indices of peaks below threshold
    sp = [l for i, l in enumerate(sp) if i not in to_remove1]  # denoised spectrum

# construct spectrum
spctr = Spectrum("", empty=True)
spctr.set_confs(sp)

# post-denoising normalization
spctr.normalize()

# parse molecule list & construct spectral list
molecules = open(args[1]).readlines()
molecules = list(map(str.strip, molecules))
molecules = [m for m in molecules if m and m[0] != '#']  # needs to be 1-prob
thr_spctrs = [Spectrum(m, 1-prob, 1) for m in molecules]

deconv = FastIPMDeconv(spctr, thr_spctrs, eps=epsilon, max_iter=max_iter)

if deconv:
    # check if no large-distance transports occur
    res_spctr = Spectrum("", empty=True)
    for s, w in zip(thr_spctrs, deconv['weights']):
        res_spctr += s*w

    mvs = [mv for mv in spctr.WSDistanceMoves(res_spctr) if mv[2] > 1e-06]
    max_mv = max(mvs, key=lambda x: abs(x[1]-x[0]))
    if abs(max_mv[1]-max_mv[0]) > 10:
        print((mass_warning % (max_mv[0], max_mv[1])))

    print()
    print("Optimal Wasserstein distance:")
    print((deconv['fun']))
    print("Isotopic envelope proportions:")
    for m, d in zip(molecules, deconv['weights']):
        print((m + '\t' + str(round(d, 10))))

    if print_transport:
        print("Optimal transport scheme:")
        for m in mvs:
            if m[2] > 1e-6:
                print(('\t'.join([str(round(m[0], 4)), str(round(m[1], 4)), str(round(m[2], 8))])))

else:
    print("Deconvolution failed. Try tweaking the program parameters or the input data.")